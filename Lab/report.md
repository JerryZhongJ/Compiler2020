# 编译原理 实验一 报告

## 词法分析
### 十进制整型数的正则
```
0|([1-9][0-9]*)
```
十进制整型数要求除了0以外其他数字不能以0开头. 因此, 只需先讨论其他情况: 以非零开头, 然后连接任意个数的数字(可以为空). 再加上0的情况, 就可以表示所有的十进制整型数了.

整型数可能有以下的"错误":
1. 开头是0: 这被当作八进制整型来讨论.
2. 出现字母或下划线: 若出现在开头则被当作标识符来讨论. 若出现在中间, 则被当作错误的标识符来讨论.
3. 出现其他字符(除了'.'): 这会被词法分析器拆成多个数字
### 浮点数的正则
```
[0-9]+\.[0-9]+
```
浮点数要求存在一个小数点, 且前后都有数字.

因此, 只需在小数点前后连接数字的正闭包即可.

浮点数可能有以下错误:
1. 小数点前没有数字或小数点后没有数字: 我们因此定义了相应的正则来讨论这种情况, 遇到则输出错误信息"Illeagal float".
	```
	[0-9]*\.|\.[0-9]*
	```
	注意: 不包含小数点前后都没有数字的情况, 因为那样就只有一个'.', 与DOT情况冲突.
2. 没有小数点: 那就是整型数.
3. 小数点有多个: 会被当作合法的浮点数连接着多个非法浮点数.
4. 出现其他字符: 可能会被当作标识符和一个点.

### 标识符的正则
```
digit : [0-9]
letter_ : [A-Za-z_]
{letter_}({letter_}|{digit})*
```
标识符要求开头不可以是数字, 其余符号可以是大小写字母和下划线.

因此, 将`letter_`定义为大小写字母和下划线的字符集, 将`digit`定义为数字字符集. 则开头是一个`letter_`, 后面可以连接若干个`letter_`或`digit` (可以为空). 由此可以表示所有的标识符.

标识符可能有以下错误:
1. 数字在前: 定义了一种正则来表示这种情况.
	```
	{digit}({letter_}|{digit})*
	```
	遇到则输出"illegal identifier"错误信息.
2. 出现其他字符: 会被词法分析器拆成多个标识符.
### 选做: 八进制 十六进制
#### 八进制
```
0[0-7]+
```
与十进制类似, 八进制以一个0开头, 后面可接若干个[0-7]. 但这里不允许后面为空, 否则将允许只有一个0的情况, 这与十进制整型冲突. 因此我们要求0后面必须有数字.

八进制可能出现以下错误:
1. 出现大于7的数字: 因此定义了一种正则来表示
	```
	0{digit}+
	```
	遇到这输出"illegal octal number"的错误信息.
2. 其他错误同十进制整型
#### 十六进制
```
0[xX][0-9A-Fa-f]+
```
以"0x"或"0X"开头, 后接数字或大小写a到f. 其中后面不允许为空.

可能的错误;
1. 出现其他字母: 
	```
	0[xX][0-9A-Za-z]+
	```
	遇到则输出"illegal hex number"的错误信息.
2. 后面为空: 被当作非法标识符处理.

### 其他词法错误
出现非法字符, 其正则表达式为`.`. 输出信息"illegal character".
### 词法单元的属性及位置
为了方便语法分析器的实现, 词法分析器要提供词法单元的属性值以及位置.
#### 属性值
对于各进制整型, 调用strtoi实现字符串到整型的转化, 返回该整型.

对于浮点数包括科学计数法, 调用strtof, 返回该浮点数.

对于标识符, 开辟一个空间存储字符串, 返回该字符指针.

对于TYPE类型, 将"int"和"float"分开匹配, 返回一个bool值.

#### 位置
根据书上来实现.

另外还需讨论注释中的column的情况.

### 额外实现: 科学计数法
```
([0-9]*\.?[0-9]+|[0-9]+\.)[Ee][+-]?[0-9]+
```
E可以为大小写, 前面接一个带小数点的数字, 且小数点可以任意位置; 后接可选'+''-'号, 再后接一个整数. 前面带小数点的数字是难点, 它包含三种情况: 小数点前后有数字, 小数点前有数字, 小数点后有数字. 它表示为`[0-9]*\.?[0-9]+|[0-9]+\.	`. 由`[0-9]*\.?[0-9]+`和`[0-9]+\.`通过选择连在一起. 前者表示, 小数点后一定有数字, 前面可有可无; 后者表示小数点前一定有数字, 后面一定没有. 通过分类讨论即可将三种情况都包含在内.

可能的错误:
1. 基数不带小数点: 见下
2. 指数带小数点:
3. 缺少指数

	上面两种情况都由`([0-9]*\.?[0-9]+|[0-9]+\.)[Ee][+-]*([0-9]*\.?[0-9]+|[0-9]+\.)?`表示, 遇到则输出"Illegal scientific notation"信息. 表示基数可能没有小数点; 指数可有可无, 指数可能含小数点;

	注意: 这个正则表达式能够表达正确科学计数法. 但根据flex的优先级关系, 只有不满足正确科学计数法规则的词素, 才会匹配这条正则表达式.
4. 缺少基数: 会被当作标识符加/减一个数字.
3. 缺少E|e: 会被当作浮点数加减一个整数.

### 额外实现: 注释
注释的实现方法稍有不同, 因为注释不是最长匹配而是最短匹配. 如行注释只匹配"//"到最近的'\n'内的所有字符; 块注释匹配"/\*"到最近的"\*/"的所有字符. 虽然可以通过设计正则表达式使匹配的词素不包含'\n', 不包含"*/" (如:`"/*"([^*]|\*+[^*/])*"*/"`可以要求匹配得到的"/\*""\*/"内的字符串包含"\*/"), 但这种实现还是过于麻烦.

通过查阅官方文档, 我了解到利用flex的start condition可以方便地实现这个功能. 首先定义两个start condition.
```
%x BLOCK_COMMENT
%x LINE_COMMENT
```
在匹配到"//", 或"\*/"时进入这两个start condition.
```
"//" {BEGIN(LINE_COMMENT);}
"/*" {BEGIN(BLOCK_COMMENT);}
```
start condition类似于命名空间. 两个相同或冲突的正则表达式可以同时存在于不同的"命名空间". 而BEGIN相当于进入这个命名空间.

在两个start conditon内定义注释的正则, 即匹配结束, 匹配任意字符串. 默认的"命名空间"是INITIAL.
```
<LINE_COMMENT>{
	{newline} {yycolumn = 1;BEGIN(INITIAL);}
	. {}
} 

<BLOCK_COMMENT>{
	"*/" { BEGIN(INITIAL);}
	<<EOF>> {yynerrs++;printf("Error type A at Line %d:%d: EOF in a block comment.\n", yylloc.first_line, yylloc.first_column);yyterminate();}
	{newline} {yycolumn = 1;}
	. {}
}
```
在进入LINE_COMMENT 或 BLOCK_COMMENT后, 匹配到的任何字符都会执行这里面的动作, 而不是INITIAL中报错"Illegal character"的动作. 在匹配到"//"或"\*/"再进入到BEGIN.

注意: BLOCK_COMMENT遇到换行也要更新yycolumn.

可能的错误:

对于块注释, 可能出现不封闭的情况, 即没有对应的"\*/". 因此, 在BLOCK_COMMENT	中加入`<<EOF>> {yynerrs++;printf("Error type A at Line %d:%d: EOF in a block comment.\n", yylloc.first_line, yylloc.first_column);yyterminate();}`, 来处理这种情况.

### 测试方法
自己写一个词法的样例, 包含正确的词法和上述的词法错误. 对于每一个匹配的词法单元, 输出其词素及其词法单元类型, 以确保准确地识别和正确地分类.

## 语法分析
### 语法树
语法树节点由结构体定义. 每个节点包含:
1. syn_type: 指定此语法单元的类型
2. symbol_num: 语法单元由句柄归纳而成. 这个值表示句柄的文法符号个数.
3. symbol_type: 每个文法符号是终结符还是非终结符.
4. symbol: 联合体. 可以是一个指向其他节点的指针, 或者是词法单元结构体.

	词法单元结构体: 
	1. lex_type: 词法单元类型.
	2. 4种类型的属性值所构成的联合体. 赋值时只能赋其中的一个
### 语法错误与恢复
#### 报错与恢复分离
我们在设计错误规则时一开始陷入了误区, 即把报错理解成匹配错误规则, 根据不同的错误规则输出不同的报错信息.

但后来发现这是错误的. 因此我们设计错误规则时采用报错与恢复分离原则, 即报错是bison遇到无法处理的输入字符时就进行, 输出信息由bison提供(可以设定`%define parse.error verbose`使bison提供错误的详细信息), 而与错误规则无关; 错误规则只与错误恢复有关, 即设计错误规则时只需考虑**什么样的情况可以被考虑成合法的非终结符**. 而且所谓**情况**不能太过宽泛, 以至于将
#### 弃小保大
我们设计错误规则时, 以语句和定义为最小单元, 不考虑恢复表达式层次的错误. 因为错误恢复粒度太小没有意义, 因为我们需要错误恢复是在于防止因为局部的错误影响全局的语法分析, 而在表达式层次错误恢复意味着可以不影响一条语句其他部分的语法分析, 而这一般都是不需要的.

而且, 引入更多的错误规则意味着引用更多的未知情况.
#### throw catch
另外, 我们在设计错误规则时还采用了异常处理中"throw catch"的思想. 即底层错误处理不了就交给上层. 如, Stmt层次的错误处理不了, 就交给StmtList处理, 一般这个错误就是"缺失分号". 
```
Stmt: error SEMI
StmtList: error StmtList
```
而这意味着, 底层的错误规则需要以error开头. 因为在错误恢复时, 先弹出栈直到找到一个能处理error的状态. 若错误规则以其他文法符号开头, 那么在弹栈时弹到这个文法符号时即停止. 

考虑:
```
Def: Specifier error SEMI
DefList: error DeflList
```
在错误恢复时, 弹栈弹到`Def: Specifier . error SEMI`处停止, 而不会弹到`Def: . Specifier error SEMI `和 `DefList: . error DefList`. 这样DefList的错误规则就没用了. 而这样会导致破坏语法结构, 如恢复Def时会一直搜索到最近的SEMI, 尽管这个SEMI是在一个语句块内, 这样就破坏了语句块的RC StmtList RC结构. 

#### 冲突处理
在满足上面的设计原则后, 最后还需处理一个移入冲突规则.
```
CompSt: error RC 	//为了恢复缺失'{'的错误
StmtList: ...
		| //empty
		| error StmtList
```
在错误发生在语句块的最后一条语句时会出现, 此时弹栈弹到`CompSt: error . "}"`和`StmtList: error . StmtList`. 可以将语句后面的空归约成StmtList; 也可以移入RC, 将语句块中的所有语句当作错误, 和'}'一起归约到`CompSt`, 尽管并没有缺失'{'. bison的默认处理是移入, 这与我们的目的不一样, 我们显然希望将最后一条错误语句和空一起归约到`StmtList`. 

因此我们将`StmtList: //empty`的优先级设置得比'}'高.
```
%precedence RC
%precedence PRIOR
StmtList: %prec PRIOR
```
#### 错误规则
```
ExtDefList:	error ExtDefList
ExtDef:	error SEMI
		| error CompSt 
ParamList:	error ParamList 
CompSt:	error RC 
StmtList:	error StmtList 
		|	Stmt error Def StmtList //处理定义出现在语句之后的情况
Stmt:	error SEMI 
DefList:	error DefList 
```
## 结果展示
### 样例1
![样例一](1.png)
### 样例3
![样例三](2.png)
### 样例5
![样例五](3.png)
### 自定义样例
![](4.png)

