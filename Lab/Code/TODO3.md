## Optimize1

遍历每一条代码, 对于:

1. 形如:

    ```
    IF ... GOTO x / GOTO x
    LABEL x
    ```

    GOTO语句与要跳转的LABEL相邻时, 删除`IF ... GOTO x` 或 `GOTO x`, 但此时, 还不能把`LABEL x`删除.

2. 形如:

   ```
    if x [relop] y GOTO a
    goto b
    LABEL a
    ```

    将第一条替换为`IF x [relop'] y GOTO b`, 其中 relop' 是 relop的反向. 删除 `GOTO b`. 此时还不能 `LABEL a` 删除.

3. 形如:

    ```
    GOTO x / 或 IF ... GOTO x
        ...
    LABEL x
    GOTO y
        ...
    LABEL y
    GOTO z
        ...
    ```
    或
    ```
    GOTO x / 或 IF ... GOTO x
        ...
    LABEL x
    LABEL y
    LABEL z
        ...
    ```

    即跳转目标的第一句就是无条件跳转, 或者, 跳转目标的开头几句还是`LABEL`.
    此时应该把`GOTO x`换成`GOTO z`, 即避免连续跳转, 或者避免重复的`LABEL`.

上述过程需要时刻维护label的ref_num计数

最后, 删除引用计数为0的LABEL, 也删掉引用计数为0的函数 (一个函数的范围就由`FUNCTION`开始到`RETURN`结束)

## Optimize2

这里进行的是基本块内的优化, 基本块之间的优化太难了. 基本块由`GOTO`, `IF GOTO`, `LABEL`, `FUNCTION`分隔.

我们假设, 基本块内引用一个临时变量时, 总是在临时变量 当前基本块中 被定值后, 因此删掉一个临时变量, 不会对其他基本块有影响.

1. 常量优化
    形如: `x := #2 + #3`, 则替换为`x := #5`, 这个可以结合"复制传播"和"公共表达式", 而且要在他们之前先优化.

2. trivial的情况
    形如`x := x`, `x := #0 + y`, `x := #0 * y`, `x := #1 * y`. 

3. 复制传播:
    形如:`x := y`, `x = &z`, y可能是个变量, 也可能是常数. (对于`*x = y`, `x = *y`不优化)
    则遍历后面的代码, 所有对x的引用, 都替换成y, 直到y被定值(即`y := z`), 或者到达了基本块边界

4. 公共表达式
    形如`x := y + z`. 则遍历后面的代码, 若有相同的表达式`a := y + z`, 则替换为`a = x`. 直到y或z被定值, 或到了表达式边界.

上述优化的效果都是对向后的(向未遍历的), 即不会因为某条代码的优化而改变前面的代码. 而且一个优化改变了后面的一条代码, 可能引发新的优化, 如:

```
a := x
b := y
c := a + b
z := x + y
```

对前两条代码使用"复制传播"优化, 会引起第四条代码的"公共表达式"优化.

因此, 应该先遍历每条代码, 再对每条代码分情况优化. 而不是对于3种优化的类型, 分别遍历3次, 这样的话可能会错过优化的机会.

可以看到, 上面的3种优化都不怎么删代码, 所以其实没啥卵用, 上面3种优化都是为下面做铺垫的

最后, 从基本块的末尾开始, 从后往前统计临时变量的使用情况, 对于没有被使用的临时变量, 比方说x, 其定值如`x := y`或`x := a + b`就可以被删掉了. 其中, 若`x := a + b`要被删掉, 那a和b就不需要标记为被使用.

## 可以尝试一下的优化

死代码优化： 若`GOTO`(无条件跳转)的下面没有`LABEL`或者`FUNCTION`, 而是其他语句, 那么这些语句将永远无法被执行, 因为`GOTO`意味着顺序执行下来, 执行不到它们; 而没有`LABEL`或`FUNCTION`意味着无法从外部跳转进来. 那么这些语句就可以被删除.